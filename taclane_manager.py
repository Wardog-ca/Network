#!/usr/bin/env python3
"""
Outil de gestion Taclane - Interface sp√©cialis√©e pour les √©quipements Taclane
Adresse IP par d√©faut: 172.16.0.1
"""

import tkinter as tk
from tkinter import ttk, messagebox
import subprocess
import threading
import socket
import time
import os
import webbrowser

def create_taclane_interface(parent, colors, log_func):
    """Cr√©e l'interface de gestion Taclane"""
    
    taclane_win = tk.Toplevel(parent)
    taclane_win.title("üõ°Ô∏è Gestionnaire Taclane")
    taclane_win.geometry("800x700")
    taclane_win.configure(bg=colors['light'])
    taclane_win.resizable(True, True)
    
    # En-t√™te
    header = tk.Frame(taclane_win, bg=colors['primary'], height=70)
    header.pack(fill=tk.X)
    header.pack_propagate(False)
    
    title_frame = tk.Frame(header, bg=colors['primary'])
    title_frame.pack(expand=True)
    
    tk.Label(title_frame, text="üõ°Ô∏è Gestionnaire Taclane", 
            font=("Arial", 18, "bold"), 
            fg=colors['white'], bg=colors['primary']).pack(pady=10)
    
    tk.Label(title_frame, text="Outil sp√©cialis√© pour √©quipements de chiffrement Taclane", 
            font=("Arial", 10), 
            fg='#ecf0f1', bg=colors['primary']).pack()
    
    # Configuration principale
    config_frame = tk.LabelFrame(taclane_win, text="üîß Configuration Taclane", 
                                bg=colors['light'], font=("Arial", 11, "bold"))
    config_frame.pack(fill=tk.X, padx=15, pady=10)
    
    # Adresse IP Taclane
    ip_frame = tk.Frame(config_frame, bg=colors['light'])
    ip_frame.pack(fill=tk.X, padx=10, pady=8)
    
    tk.Label(ip_frame, text="üåê Adresse IP Taclane:", 
            font=("Arial", 10, "bold"), bg=colors['light']).pack(side=tk.LEFT)
    
    ip_var = tk.StringVar(value="172.16.0.1")
    ip_entry = tk.Entry(ip_frame, textvariable=ip_var, width=15, font=("Arial", 10))
    ip_entry.pack(side=tk.LEFT, padx=10)
    
    # Statut de connexion
    status_label = tk.Label(ip_frame, text="‚ö™ Non test√©", 
                           font=("Arial", 10, "bold"), fg=colors['secondary'])
    status_label.pack(side=tk.LEFT, padx=20)
    
    def test_connection():
        """Test de connectivit√© vers le Taclane"""
        ip = ip_var.get()
        status_label.config(text="üü° Test en cours...", fg=colors['warning'])
        taclane_win.update()
        
        def ping_test():
            try:
                # Test ping
                result = subprocess.run(['ping', '-c', '3', '-W', '2000', ip], 
                                      capture_output=True, text=True, timeout=10)
                
                if result.returncode == 0:
                    status_label.config(text="üü¢ Connect√©", fg=colors['success'])
                    log_func(f"‚úÖ Taclane {ip} accessible")
                    
                    # Test des ports communs Taclane
                    test_ports([80, 443, 22, 23, 161], ip)
                else:
                    status_label.config(text="üî¥ Hors ligne", fg=colors['danger'])
                    log_func(f"‚ùå Taclane {ip} non accessible")
                    
            except Exception as e:
                status_label.config(text="üî¥ Erreur", fg=colors['danger'])
                log_func(f"‚ùå Erreur test Taclane: {e}")
        
        threading.Thread(target=ping_test, daemon=True).start()
    
    def test_ports(ports, ip):
        """Test des ports sur le Taclane"""
        open_ports = []
        for port in ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(2)
                result = sock.connect_ex((ip, port))
                if result == 0:
                    open_ports.append(port)
                sock.close()
            except:
                pass
        
        if open_ports:
            log_func(f"üîì Ports ouverts sur {ip}: {', '.join(map(str, open_ports))}")
            update_port_status(open_ports)
    
    tk.Button(ip_frame, text="üîç Tester", command=test_connection,
             bg=colors['info'], fg=colors['white'], padx=10).pack(side=tk.LEFT, padx=5)
    
    # Outils de diagnostic
    diagnostic_frame = tk.LabelFrame(taclane_win, text="üîç Outils de Diagnostic", 
                                   bg=colors['light'], font=("Arial", 11, "bold"))
    diagnostic_frame.pack(fill=tk.X, padx=15, pady=10)
    
    # Grille d'outils de diagnostic
    diag_grid = tk.Frame(diagnostic_frame, bg=colors['light'])
    diag_grid.pack(padx=10, pady=10)
    
    diagnostic_tools = [
        ("üèì Ping Continu", lambda: start_continuous_ping(ip_var.get())),
        ("üìä Traceroute", lambda: run_traceroute(ip_var.get())),
        ("üîå Scan Ports", lambda: run_port_scan(ip_var.get())),
        ("üìà Monitoring", lambda: start_monitoring(ip_var.get())),
        ("üåê Interface Web", lambda: open_web_interface(ip_var.get())),
        ("üìã ARP Table", lambda: show_arp_info(ip_var.get()))
    ]
    
    for i, (name, command) in enumerate(diagnostic_tools):
        row, col = i // 3, i % 3
        btn = tk.Button(diag_grid, text=name, command=command,
                       bg=colors['info'], fg=colors['white'], 
                       width=15, pady=5, font=("Arial", 9))
        btn.grid(row=row, column=col, padx=5, pady=5)
    
    # Informations syst√®me
    info_frame = tk.LabelFrame(taclane_win, text="üìä Informations Syst√®me", 
                              bg=colors['light'], font=("Arial", 11, "bold"))
    info_frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=10)
    
    # Notebook pour organiser les informations
    notebook = ttk.Notebook(info_frame)
    notebook.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
    
    # Onglet Statut
    status_tab = tk.Frame(notebook, bg=colors['white'])
    notebook.add(status_tab, text="üìä Statut")
    
    status_text = tk.Text(status_tab, height=8, bg=colors['white'], 
                         font=("Consolas", 9), wrap=tk.WORD)
    status_scroll = tk.Scrollbar(status_tab, orient=tk.VERTICAL, command=status_text.yview)
    status_text.configure(yscrollcommand=status_scroll.set)
    
    status_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)
    status_scroll.pack(side=tk.RIGHT, fill=tk.Y)
    
    # Onglet Logs
    logs_tab = tk.Frame(notebook, bg=colors['white'])
    notebook.add(logs_tab, text="üìù Logs")
    
    logs_text = tk.Text(logs_tab, height=8, bg=colors['white'], 
                       font=("Consolas", 9), wrap=tk.WORD)
    logs_scroll = tk.Scrollbar(logs_tab, orient=tk.VERTICAL, command=logs_text.yview)
    logs_text.configure(yscrollcommand=logs_scroll.set)
    
    logs_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)
    logs_scroll.pack(side=tk.RIGHT, fill=tk.Y)
    
    # Onglet Configuration
    config_tab = tk.Frame(notebook, bg=colors['white'])
    notebook.add(config_tab, text="‚öôÔ∏è Config")
    
    config_text = tk.Text(config_tab, height=8, bg=colors['white'], 
                         font=("Consolas", 9), wrap=tk.WORD)
    config_scroll = tk.Scrollbar(config_tab, orient=tk.VERTICAL, command=config_text.yview)
    config_text.configure(yscrollcommand=config_scroll.set)
    
    config_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)
    config_scroll.pack(side=tk.RIGHT, fill=tk.Y)
    
    # Variables globales pour les fonctions
    monitoring_active = [False]
    port_status = {}
    
    def update_port_status(open_ports):
        """Met √† jour le statut des ports"""
        nonlocal port_status
        port_status = {port: True for port in open_ports}
        
        port_info = "üîì Ports ouverts d√©tect√©s:\n"
        port_descriptions = {
            80: "HTTP - Interface web",
            443: "HTTPS - Interface web s√©curis√©e", 
            22: "SSH - Administration √† distance",
            23: "Telnet - Console d'administration",
            161: "SNMP - Monitoring r√©seau"
        }
        
        for port in open_ports:
            desc = port_descriptions.get(port, "Service inconnu")
            port_info += f"  ‚Ä¢ Port {port}: {desc}\n"
        
        status_text.delete(1.0, tk.END)
        status_text.insert(tk.END, port_info)
    
    def start_continuous_ping(ip):
        """Lance un ping continu"""
        def continuous_ping():
            try:
                log_func(f"üèì Ping continu vers {ip} d√©marr√©")
                process = subprocess.Popen(['ping', ip], 
                                         stdout=subprocess.PIPE, 
                                         stderr=subprocess.PIPE,
                                         text=True, universal_newlines=True)
                
                ping_win = tk.Toplevel(taclane_win)
                ping_win.title(f"üèì Ping continu - {ip}")
                ping_win.geometry("600x400")
                
                ping_text = tk.Text(ping_win, bg='black', fg='green', 
                                   font=("Consolas", 10))
                ping_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
                
                def update_ping():
                    if process.poll() is None:
                        line = process.stdout.readline()
                        if line:
                            ping_text.insert(tk.END, line)
                            ping_text.see(tk.END)
                        ping_win.after(100, update_ping)
                
                update_ping()
                
                def stop_ping():
                    process.terminate()
                    ping_win.destroy()
                
                tk.Button(ping_win, text="‚èπÔ∏è Arr√™ter", command=stop_ping,
                         bg=colors['danger'], fg=colors['white']).pack(pady=5)
                
            except Exception as e:
                log_func(f"‚ùå Erreur ping: {e}")
        
        threading.Thread(target=continuous_ping, daemon=True).start()
    
    def run_traceroute(ip):
        """Ex√©cute un traceroute"""
        def traceroute():
            try:
                log_func(f"üìä Traceroute vers {ip}")
                result = subprocess.run(['traceroute', ip], 
                                      capture_output=True, text=True, timeout=30)
                
                trace_win = tk.Toplevel(taclane_win)
                trace_win.title(f"üìä Traceroute - {ip}")
                trace_win.geometry("700x500")
                
                trace_text = tk.Text(trace_win, bg=colors['white'], 
                                   font=("Consolas", 9))
                trace_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
                
                trace_text.insert(tk.END, result.stdout)
                if result.stderr:
                    trace_text.insert(tk.END, f"\nErreurs:\n{result.stderr}")
                
            except Exception as e:
                log_func(f"‚ùå Erreur traceroute: {e}")
        
        threading.Thread(target=traceroute, daemon=True).start()
    
    def run_port_scan(ip):
        """Scan complet des ports"""
        def port_scan():
            try:
                log_func(f"üîå Scan des ports sur {ip}")
                common_ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995, 161, 162, 8080, 8443]
                
                scan_results = []
                for port in common_ports:
                    try:
                        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                        sock.settimeout(1)
                        result = sock.connect_ex((ip, port))
                        if result == 0:
                            scan_results.append(f"üü¢ Port {port}: OUVERT")
                        else:
                            scan_results.append(f"üî¥ Port {port}: FERM√â")
                        sock.close()
                    except:
                        scan_results.append(f"‚ùì Port {port}: ERREUR")
                
                # Afficher les r√©sultats
                scan_info = f"üîå R√©sultats du scan pour {ip}:\n\n"
                scan_info += "\n".join(scan_results)
                
                logs_text.delete(1.0, tk.END)
                logs_text.insert(tk.END, scan_info)
                
                log_func(f"‚úÖ Scan termin√© pour {ip}")
                
            except Exception as e:
                log_func(f"‚ùå Erreur scan ports: {e}")
        
        threading.Thread(target=port_scan, daemon=True).start()
    
    def start_monitoring(ip):
        """D√©marre le monitoring continu"""
        if monitoring_active[0]:
            monitoring_active[0] = False
            log_func("üõë Monitoring arr√™t√©")
            return
        
        monitoring_active[0] = True
        log_func(f"üìà Monitoring d√©marr√© pour {ip}")
        
        def monitor():
            ping_count = 0
            success_count = 0
            
            while monitoring_active[0]:
                try:
                    # Test ping
                    result = subprocess.run(['ping', '-c', '1', '-W', '1000', ip], 
                                          capture_output=True, timeout=5)
                    
                    ping_count += 1
                    if result.returncode == 0:
                        success_count += 1
                        status = "üü¢ ACTIF"
                    else:
                        status = "üî¥ INACTIF"
                    
                    # Calculer la disponibilit√©
                    availability = (success_count / ping_count) * 100 if ping_count > 0 else 0
                    
                    # Mettre √† jour l'affichage
                    monitor_info = f"üìà Monitoring Taclane {ip}\n"
                    monitor_info += f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                    monitor_info += f"Statut actuel: {status}\n"
                    monitor_info += f"Tests effectu√©s: {ping_count}\n"
                    monitor_info += f"Succ√®s: {success_count}\n"
                    monitor_info += f"Disponibilit√©: {availability:.1f}%\n"
                    monitor_info += f"Derni√®re v√©rification: {time.strftime('%H:%M:%S')}\n"
                    
                    if ping_count > 1:
                        monitor_info += f"\nüìä Historique des 10 derniers tests:\n"
                    
                    config_text.delete(1.0, tk.END)
                    config_text.insert(tk.END, monitor_info)
                    
                    time.sleep(5)  # Attendre 5 secondes
                    
                except Exception as e:
                    log_func(f"‚ùå Erreur monitoring: {e}")
                    break
        
        threading.Thread(target=monitor, daemon=True).start()
    
    def open_web_interface(ip):
        """Ouvre l'interface web du Taclane"""
        try:
            # Essayer HTTPS d'abord, puis HTTP
            urls = [f"https://{ip}", f"http://{ip}"]
            
            for url in urls:
                try:
                    webbrowser.open(url)
                    log_func(f"üåê Interface web ouverte: {url}")
                    break
                except:
                    continue
                    
        except Exception as e:
            log_func(f"‚ùå Erreur ouverture interface web: {e}")
    
    def show_arp_info(ip):
        """Affiche les informations ARP"""
        def get_arp():
            try:
                result = subprocess.run(['arp', '-a'], capture_output=True, text=True)
                
                arp_win = tk.Toplevel(taclane_win)
                arp_win.title("üìã Table ARP")
                arp_win.geometry("600x400")
                
                arp_text = tk.Text(arp_win, bg=colors['white'], font=("Consolas", 9))
                arp_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
                
                arp_text.insert(tk.END, f"üìã Table ARP - Recherche de {ip}\n")
                arp_text.insert(tk.END, "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n")
                arp_text.insert(tk.END, result.stdout)
                
                # Rechercher sp√©cifiquement l'IP Taclane
                if ip in result.stdout:
                    arp_text.insert(tk.END, f"\n‚úÖ Entr√©e ARP trouv√©e pour {ip}")
                else:
                    arp_text.insert(tk.END, f"\n‚ùå Aucune entr√©e ARP pour {ip}")
                
            except Exception as e:
                log_func(f"‚ùå Erreur ARP: {e}")
        
        threading.Thread(target=get_arp, daemon=True).start()
    
    # Initialiser les informations par d√©faut
    default_info = """üõ°Ô∏è Gestionnaire Taclane - Informations par d√©faut

üìã Configuration typique Taclane:
‚Ä¢ Adresse IP: 172.16.0.1 (r√©seau priv√©)
‚Ä¢ Ports communs: 80 (HTTP), 443 (HTTPS), 22 (SSH)
‚Ä¢ Interface: Web-based management
‚Ä¢ Protocoles: SNMP, SSH, Telnet possible

üîß Outils disponibles:
‚Ä¢ Test de connectivit√© ping
‚Ä¢ Scan des ports de service
‚Ä¢ Monitoring de disponibilit√©
‚Ä¢ Acc√®s interface web administrative
‚Ä¢ Diagnostic r√©seau avanc√©

‚ö†Ô∏è Note de s√©curit√©:
Les √©quipements Taclane sont des dispositifs de chiffrement sensibles.
Assurez-vous d'avoir les autorisations appropri√©es avant utilisation."""
    
    status_text.insert(tk.END, default_info)
    status_text.config(state='disabled')
    
    # Logs initiaux
    logs_text.insert(tk.END, f"üìù Session d√©marr√©e - {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
    logs_text.insert(tk.END, f"üõ°Ô∏è Outil Taclane initialis√© pour {ip_var.get()}\n")
    
    # Configuration par d√©faut
    config_info = """‚öôÔ∏è Configuration Taclane

üåê R√©seau:
‚Ä¢ Segment: 172.16.0.0/24
‚Ä¢ Passerelle probable: 172.16.0.254
‚Ä¢ Masque: 255.255.255.0

üîí S√©curit√©:
‚Ä¢ Chiffrement: AES-256 (typique)
‚Ä¢ Authentification: Certificats/PSK
‚Ä¢ Management: HTTPS recommand√©

üîß Maintenance:
‚Ä¢ V√©rification r√©guli√®re de connectivit√©
‚Ä¢ Monitoring des performances
‚Ä¢ Surveillance des logs d'erreur
‚Ä¢ Mise √† jour firmware si n√©cessaire"""
    
    config_text.insert(tk.END, config_info)
    
    # Fermeture propre
    def on_closing():
        monitoring_active[0] = False
        taclane_win.destroy()
    
    taclane_win.protocol("WM_DELETE_WINDOW", on_closing)
    
    return taclane_win